## 总结：从多线程到Event Loop全面梳理

### CPU 进程 线程之间的关系
CPU就像一座工厂，进程就比如工厂里的车间，假如工厂的电力(CPU的资源)只够一个车间(进程)进行运转，多个车间运行会导致电力不足(进程崩溃), 而在一个车间可以有很多的工人(线程), 他们共享车间的资源，协同的完成任务。
总结：
1. **进程**是CPU分配资源的最小单位(是能拥有资源和独立运行的最小单位)。
2. **线程**是CPU资源调度的最小单位(线程是建立在进程的基础上的一次程序运行单位，一个进程可以拥有多个线程)。
3. **单线程**和**多线程**都是指一个进程单和多

### 浏览器是多进程的
- 浏览器是多进程的
- 每一个Tab页，就是一个独立的进程

问题&Q: 浏览器包括哪些进程？
回答&A:
- 主进程
  1. 协调控制其他子进程
  2. 浏览器界面显示，用户交互，前进后退，收藏
  3. 将渲染进程得到的内存的BitMap，绘制到用户界面上
  4. 处理不可见的操作，网络请求，文件读写等

- 第三方插件进程
  1. 每种类型的插件对应一个进程，仅当使用该插件创建

- GPU进程
  1. 用于3D渲染等

- 渲染进程
  1. 负责页面渲染，脚本执行和事件处理
  2. 每个tab页一个渲染进程

对于前端来说，最重要的是渲染进程。那么就让我们来深入了解下它吧。
### 渲染进程也是多线程的
- GUI渲染线程
  1. 负责渲染页面，布局和绘制。
  2. 页面需要重绘和回流时，该进程就会执行
  3. 与js引擎互斥，防止渲染结果不可预期

- js引擎线程
  1. 负责处理，解析和执行js脚本程序
  2. 只有一个js引擎线程(单线程)
  3. 与渲染引擎互斥，防止渲染结果不可预期

- 事件触发线程
  1. 用来控制事件循环（鼠标点击、setTimeout、ajax等）
  2. 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中

- 定时触发器线程
  1. setInterval与setTimeout所在的线程
  2. 定时任务并**不是由JS引擎计时的，是由定时触发线程来计时的**
  3. 计时完毕后，通知事件触发线程

- 异步http请求线程
  1. 浏览器有一个单独的线程用于处理AJAX请求
  2. 当请求完成时，若有回调函数，通知事件触发线程

问题&Q: 1. 为什么 javascript 是单线程的? 2. GUI 渲染线程为什么与 JS 引擎线程互斥?

### 为什么 javascript 是单线程的?
1. javascript的主要用途 是与用户互动，以及DOM操作，这决定他只能是单线程的，否则会带来很大同步的问题
例如：假如js是有两个线程的，这时在对同一个DOM进行操作的时候，一个在这个DOM添加内容，一个在删除这个DOM，那么该以哪个线程为准呢？
所以为了避免复杂性，js从一开始就是单线程的。

### GUI 渲染线程为什么与 JS 引擎线程互斥?
这是由于 JS是可以操作DOM的，假如JS在操作DOM的同时，渲染进程又在渲染DOM，这样会导致前后是不一致的
因此GUI线程和JS渲染进程是互斥的，当JS引擎线程执行时GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行。

### 从 Event Loop 看 JS 的运行机制
1. js分为同步任务和异步任务
2. 同步任务都在主线程上执行，形成一个执行栈
3. 主线程外，事件触发线程管理着一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件
4. 一旦所有同步任务执行完成，系统就会读取任务队列，将可执行的异步任务添加到可执行栈中，开始执行

- js的异步运行机制
1. 所有同步任务都在主线程上执行，形成一个执行栈
2. 主线程之外，还存在一个"任务队列"，只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4. 主线程不断重复上面的第三步。

我们知道，不管是setTimeout/setInterval和XHR/fetch代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。
***重点***
```js
当代码执行到setTimeout/setInterval时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件，
而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由事件触发线程所管理的事件队列中。

当代码执行到XHR/fetch时，实际上是JS引擎线程通知异步http请求线程，发送一个网络请求，并制定请求完成后的回调事件，
而异步http请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程所管理的事件队列中。

当我们的同步任务执行完，JS引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给JS引擎线程执行
```
- 总结：
1. JS引擎线程只执行执行栈中的事件
2. 执行栈中的代码执行完毕，就会读取事件队列中的事件
3. 事件队列中的回调事件，是由各自线程插入到事件队列中的
4. 如此循环

### 宏任务((macro)task)
- 每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。
- 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 
（宏任务-->渲染-->宏任务-->渲染-->渲染．．．）

❗ setTimeout的作用是等待给定的时间后为他的回调产生一个宏任务
❗ async函数中在await之前的代码是立即执行的

宏任务举例：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate

### 微任务
- 微任务通常来说就是需要在当前 task 执行结束后立即执行的任务
- 所有微任务总会在下一个宏任务之前全部执行完毕。

总结：
1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
