## 从 HTTP 到 HTTP2.0
三个考点:
- HTTP 请求方法；
- HTTP 状态码；
- 对无状态的理解。

### HTTP 状态码
RFC定义的状态码，第一位指定响应类别，后两位无分类
- 1xx：成功接收了请求，但是处理过程还没结束，需要客户端再抛出一个请求才能完成整个过程。
-  2XX 成功
1. 200 OK 表示客户端发送的请求在服务器被正确处理
2. 204 NO content 表示请求成功，但响应报文不含实体的主体部分
3. 206 Partial Content 表示客户端进行了范围请求

- 3XX 重定向(响应结果表明浏览器需要执行某些特殊的处理以完成请求。)
1. 301 moved permanently 永远性重定向，表示资源已经被分配了新的URL
2. 302 found 临时性重定向，表示资源已经被分配了新的URL
3. 303 See Other 表示资源存在另一个URL，应使用GEt方法请求。 与302不同，如果请求方式是POST，302不会改变请求方式，303会重定向为GET
4. 304 Not Modified 表示客户端发送附带条件时，服务器允许请求访问资源，但是未满足条件。
5. 307 Temporary Redirect 临时重定向，该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)

- 4XX 客户端错误
1. 400 Bad Request 表示请求报文存在语法错误，服务器无法理解该请求
2. 401 Unauthorized 表示发送的请求需要有通过 HTTP 认证的认证信息
3. 403 forbidden 表示对请求资源的访问被服务器拒绝了。
4. 404 Not Found 表示在服务器上没有找到请求的资源。

- 5XX 服务器错误
1. 500 internal sever error 表示服务器在执行请求时发生错误。
2. 503 Service Unavailable 表明服务器暂时处于超负载或正在停机维护，无法处理请求


### HTTP请求方法
HTTP 协议常考的请求方法有 GET、POST、HEAD、PUT、DELETE、OPTIONS。
1. GET方法。 用作读取数据，在url中
2. POST方法。创建新资源或者修改资源，存在于HTTPbody中
3. HEAD方法。只请求页面的请求头，不请求body中的内容。单纯的请求响应头的数据
4. PUT方法。类似于POST方法
5. DELETE方法。删除指定资源
6. OPTIONS方法。用于获取服务器能支持的通信选项

### 对无状态的理解
HTTP的无状态，指的是"无记忆"的，HTTP协议，对请求的的人时不关心的，他不知道是谁来过，谁没有来，也不会对来的人进行记忆，同时两个不同的请求也是无法感知到对方的。
所以该如何维护HTTP的无状态呢？这时候就需要用到session和cookie这两个机制了,请阅读cookie和session部分

## HTTP1.1解决的问题
在HTTP1.1之前，每进行一次HTTP通信，都要经历一次TCP的三次握手和四次挥手，这是非常消耗资源的。
改进：HTTP1.1实现了长连接，或者叫持久连接(keep-alive),只要任意一端没有明确提出断开连接，就不会断开

队头阻塞问题：在HTTP1.1之前，每个请求都必须响应完全才能接下一个请求，如果上一个请求一直未完成，就会一直堵塞
改进：HTTP1.1采用了管线化来处理堵塞问题，允许多个请求同时进行，但是还是为能从根源解决堵塞问题

## HTTP2.0解决的问题

### 二进制分帧
HTTP2.0之前，传输是以文本的格式传输的，解析起来比较低效
改进：HTTP2.0会在传输消息的时候，会将消息划为更小的帧，然后以二进制编码，确保解析的高效

### 头部压缩
HTTP2.0之前，每次传输都会携带请求头部，非常笨重。
改进：在HTTP2.0中，客户端和服务端都会维护一份相同的静态字典，里面存储了常见头部名称和值。同时还会维护一份相同的动态字典，通信间，只需要发送与请求头不同的部分，其他的部分从字典获取，就不需要来回都携带一切重复的头部。

### 多路复用
完全解决了HTTP1.1之前未完全解决的对头堵塞问题(HTTP1.1是用管线化解决的)

### 服务器推送
不在被动的接收文件了，也可以新建Stream给客户端发送消息