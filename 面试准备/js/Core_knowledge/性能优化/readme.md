## 性能优化
### webpack打包文件体积过大？（最终打包为一个js文件）
	1.异步加载模块
	2.提取第三库
	3.代码压缩
	4.去除不必要的插件

### 如何优化webpack构建的性能
- 减少代码体积 
  1. 使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积
  2. 把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理
  3. 对一些组件库采用按需加载，避免无用的代码
- 减少目录检索范围
  1. ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度	
- 减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias


- 我们把开发中的所有资源（图片，js、css文件）都看成模块，通过loader和plugins来对资源进行处理，打包成符合生产环节部署的前端资源。
							
### 移动端的性能优化
1. 首屏加载和按需加载，懒加载
2. 资源预加载
3. 图片压缩处理，使用base64内嵌图片
4. 合理缓存dom对象
5. 使用touchstart代替click（click 300毫秒的延迟）
6. 利用transform:translateZ(0)，开启硬件GUP加速
7. 不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明
8. 使用viewport固定屏幕渲染，加速页面渲染内容
9. 尽量使用事件代理，避免直接事件绑定

### Vue的SPA 如何优化加载速度
	1.减少入口文件体积
	2.静态资源本地缓存
	3.开启Gzip压缩
	4.使用SSR,nuxt.js

### 移动端300ms延迟
	由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。
	     由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作
	    因次，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕
	解决方案：1.禁用缩放，设置meta标签 user-scalable=no
		  2.fastclick.js
			原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即
			      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉
	fastclick.js还可以解决穿透问题

### 页面的重构；
  在不改变外部行为的前提下，简化结构、添加可读性

### 图片的懒加载和预加载
- 预加载：提前加载图片，当用户需要查看是可以直接从本地缓存中渲染
	  为什么要使用预加载：在网页加载之前，对一些主要内容进行加载，以提供用户更好的体验，减少等待时间。
			      否则，如果一个页面的内容过于庞大，会出现留白。
		解决页面留白的方案：1.预加载  2.使用svg站位图片，将一些结构快速搭建起来，等待请求的数据来了之后，替换当前的占位符
	实现预加载的方法：
	 		1.使用html标签
			2.使用Image对象
			3.使用XMLHTTPRequest对像，但会精细控制预加载过程



- 懒加载（lazyload）：客户端优化，减少请求数和延迟请求数
		提升用户体验，
		减少无效资源的加载
		防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用
	  原理：首先将页面上的图片的src属性设置为空字符串，而图片的真是路经则设置带data-original属性中，
		当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入到可视区域
		，如果图片在可视区域将图片的src属性设置为data-original的值，这样就可以实现延迟加载。	