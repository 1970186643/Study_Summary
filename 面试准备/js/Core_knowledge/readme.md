## 如何理解闭包？
面试官不仅仅想聊聊闭包，甚至一些作用域，作用域链，暂时性锁区，变量提示，执行上下文，甚至想问问你 JS 中的不同异常之间本质的区别在哪里？词法作用域模型又是啥？

### 作用域的运行机制
每一们语言，都可以存储变量中的值，并且允许我们读取和修改他们，而这套查找变量和修改的规则就是我们说的作用域。
看下面的代码：
```js
var name = 'duowu';
这句话在js引擎中有两个步骤

第一步var name 是在编译时处理的
第二步name = 'duowu'; 是运行的时候进行的
```
事实上，js也有编译阶段，它和传统的语言区别在于，js不会早早地把编译工作做完，而是一边编译一边进行的。简单来说，所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行

- 编译阶段
编译器会查找当前作用域，看是否有一个name的变量，如果有就会忽略name的声明，继续编译下去，如果没有，就会新增一个name的变量
- 执行阶段
js引擎在执行代码的时候会查找是不是有一个name的家伙，如果有会给它赋值，如果没有，他会作用域向上查找，如果还是没有，会爆错

### 作用域套作用域，就有了作用域链
作用域的本质就是存储和查找变量的规则

- 在 JS 世界中，目前已经有了三种作用域：
1. 全局作用域
2. 函数作用域
3. 块作用域

###  执行上下文
一个看不见得对象，存在若干个属性和变量，它被调用的时候创建的。函数被调用查看的this指向的object，object就是上下文（只有被调用的时候创建）
1. 全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中
2. 函数上下文 —— 在函数调用时创建的上下文
3. Eval 执行上下文 —— 运行 Eval 函数中的代码时所创建的环境，Eval 被前端诟病多年，时下对 Eval 感兴趣的人非常少了，面试官也普遍对它嗤之以鼻。大家答题时只需要说明 “我不用 Eval”，直接跳过这个东西就好了（还可以拉一波好感度，说明你是一个明辨是非的好孩子）。综上所述，Eval 执行上下文，不在我们本文的讨论范围内。


