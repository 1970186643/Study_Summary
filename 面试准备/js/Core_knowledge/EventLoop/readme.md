## 如何理解EventLoop ———— 宏任务和微任务  

在js中，大部分的任务都是在主线程上运行的，常见的任务有:
1. 渲染任务
2. 用户交互事件
3. 运行的js脚本
4. 网络请求，文件读写完成事件等等

为了让这些任务能有条不紊的运行着，js引擎采取的是一种**队列**的方式来存储这些任务，即先进来的先执行。模拟如下：
```js
bool keep_running = true;
void MainTherad(){
  for(;;){
    //执行队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    
    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
```
### 任务队列
单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

- js的异步运行机制
1. 所有同步任务都在主线程上执行，形成一个执行栈

2. 主线程之外，还存在一个"任务队列"，只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

4. 主线程不断重复上面的第三步。

除了上述提到的任务队列，还有一个延迟队列，它专门处理setTimeout/setInterval这样的定时的回调函数

上述提到的，普通任务队列和延迟任务队列都是**宏任务**

对于每个**宏任务**而言，其中内部都有一个微任务队列。
问题&Q：为什么要引入微任务呢？微任务在什么时候执行？

回答&A: 引入微任务的初衷，是为了异步回调的问题，对于异步回调的处理，有多少种方式？总结起来有两点:
- 将异步回调进行宏任务队列的入队操作。
- 将异步回调放到当前宏任务的末尾。
如果是第一种，那么执行的回调的时机应该在**前面的宏任务**完成之后，倘若宏任务队列有非常的长，这样就会导致异步回调一直得不到解决。

为了解决这种问题，js引擎采用了微任务来处理。在每个宏任务队列中定义一个微任务队列，当这个宏任务完成后，会去解决其中的微任务队列。微任务为空后，才会继续下一个宏任务

常见的微任务有MutationObserver、Promise.then(或.reject) 以及以 Promise 为基础开发的其他技术(比如fetch API), 还包括 V8 的垃圾回收过程。